<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<pre>
			pending:等待状态 正在进行异步的过程，数据请求中
			fulfill：满足状态 请求成功
			reject：拒绝状态 请求失败
		</pre>
		<script src="jquery.min.js" type="text/javascript" charset="utf-8"></script>
		<script type="text/javascript">
			// 什么情况下需要promise？
			// 1.一般情况下是有异步操作的时候
			// promise 的两个参数，第二个可传可不传

			// // 写法一
			// new Promise((resolve, reject) => {
			// 	setTimeout(() => {
			// 		// resolve("success,请求成功后去then")
			// 		reject("写法一：error,请求失败后去catch")
			// 	}, 1000)
			// }).then((data) => {
			// 	console.log(data)
			// 	return new Promise((resolve, reject) => {
			// 		setTimeout(() => {
			// 			// resolve("success2,请求成功后去then")
			// 			reject("写法一：error2,请求失败后去catch")
			// 		}, 1000)
			// 	})
			// }).catch((err) => {
			// 	console.log(err)catch要和上面的reject进行配合，两者须同时存在
			// })

			// // 写法二
			// new Promise((resolve, reject) => {
			// 	setTimeout(() => {
			// 		resolve("写法二:success")
			// 		reject("写法二:error")
			// 	}, 1000)
			// }).then(data => {
			// 	console.log(data)

			// 	return new Promise((resolve, reject) => {
			// 		resolve("写法二 success2")
			// 		reject("写法二 err2")
			// 	})
			// }, err => {
			// 	console.log(err)
			// }).then(data => {
			// 	console.log(data)
			// }, err => {
			// 	console.log(err)
			// })

			//// 写法三，简写
			//new Promise((resolve, reject) => {
			//	setTimeout(() => {
			//		resolve("简写 resolve")
			//		reject("简写 reject")
			//	})
			//}).then((data) => {
			//	console.log(data)
			//	return Promise.resolve("简写一：直接return Promise.resolve或Promise.reject")
			//}).then(data => {
			//	console.log(data)
			//	return "简写二，直接return数据"
			//}).then(data => {
			//	console.log(data)
			//	throw "err,除了catch也可以手动抛出异常，throw"
			//}).catch(err => {
			//	// 这里既可以捕获throw的异常也可以捕获reject的异常
			//	console.log(err)
			//})
			
			// 超级简写
//			new Promise((resolve,reject) => {
//				setTimeout(() => {
//					resolve(0)
//				})
//			}).then((res) => {
//				console.log(res)
//				return res+1//内部会对这句进行promise包装
//			}).then((res) => {
//				console.log(res)
//				return res+1//内部会对这句进行promise包装
//			}).then((res) => {
//				console.log(res)
//				return res+1//内部会对这句进行promise包装
//			})

			// promise.all的操作
			// promise.all 是针对需要同时需要两个或以上的接口全部获取到，才能继续操作的操作
			// 例如，ajax请求一得到日期，ajax请求二得到名字
						Promise.all([
							new Promise((resolve, reject) => {
								askajax(resolve, reject)
							}),
							new Promise((resolve, reject) => {
								askajax(resolve, reject)
							}),
						]).then((res) => {
							// 它会等待all的数组里面所有的项都执行完成后才会进来
							console.log(res)
						}, (err) => {
							console.log("err:" + err)
						})
						
			// 以上函数用promise，等于以下操作
			new Promise((resolve, reject) => {
				askajax(resolve, reject)
			}).then((res) => {
				console.log("第一次回调处理", res)
				return new Promise((resolve, reject) => {
					askajax(resolve, reject)
				})
			},err => {
				console.log(err)
			}).then((res) => {
				console.log("第二次回调处理", res)
				return new Promise((resolve, reject) => {
					askajax(resolve, reject)
				})
			}).then((res) => {
				console.log("第三次回调处理", res)
			})

			function askajax(fn, errback) {
				var obj = new Object();
				$.ajax({
					type: "get",
					url: "http://rap2api.taobao.org/app/mock/229799/getArray2",
					data: obj,
					dataType: "json",
					success: function(result) {
						fn && fn(result)
					},
					err:function(err){
						errback && errback(result)
					}
				})
			}
			
		</script>
	</body>
</html>
